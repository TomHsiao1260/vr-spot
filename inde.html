<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Hsiao Yao</title>
		<meta charset="utf-8">
		<meta http-equiv="x-ua-compatible" content="ie=edge">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="style.css">
		<link rel="shortcut icon" href="gatsby-icon.png">
		<meta name="description" content="Website built by Hsiao Yao who is an art lover with physics and engineering background.">
		<meta name="image" content="https://tomhsiao1260.github.io/Demo/images/Yao.png">
		<meta property="og:locale" content="en_US">
		<meta property="og:url" content="https://tomhsiao1260.github.io/Demo/">
		<meta property="og:type" content="website">
		<meta property="og:title" content="Hsiao Yao">
		<meta property="og:description" content="Website built by Hsiao Yao who is an art lover with physics and engineering background.">
		<meta property="og:image" content="https://tomhsiao1260.github.io/Demo/images/Yao.png">
		<meta property="og:image:alt" content="Website built by Hsiao Yao who is an art lover with physics and engineering background.">
		<meta name="twitter:card" content="summary_large_image">
		<meta name="twitter:title" content="Hsiao Yao">
		<meta name="twitter:description" content="Website built by Hsiao Yao who is an art lover with physics and engineering background.">
		<meta name="twitter:image" content="https://tomhsiao1260.github.io/Demo/images/Yao.png">
		<meta name="twitter:image:alt" content="Website built by Hsiao Yao who is an art lover with physics and engineering background.">
		<script type="application/ld+json">{"@context":"http://schema.org","@type":"WebPage","url":"https://tomhsiao1260.github.io","headline":"This is a Hsiao Yao personal website.","inLanguage":"en","mainEntityOfPage":"https://tomhsiao1260.github.io","description":"Website built by Hsiao Yao who is an art lover with physics and engineering background.","name":"Hsiao Yao","author":{"@type":"Person","name":"Hsiao Yao"},"copyrightHolder":{"@type":"Person","name":"Hsiao Yao"},"copyrightYear":"2020","creator":{"@type":"Person","name":"Hsiao Yao"},"publisher":{"@type":"Person","name":"Hsiao Yao"},"datePublished":"2019-10-30T13:31:15.000Z","dateModified":"2020-01-16","image":{"@type":"ImageObject","url":"https://tomhsiao1260.github.io/images/gatsby-icon.png"}}</script>
		<script type="application/ld+json">{"@context":"http://schema.org","@type":"BreadcrumbList","description":"Breadcrumbs list","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","item":{"@id":"https://tomhsiao1260.github.io","name":"Homepage"},"position":1}]}</script>
		<meta name="theme-color" content="#000000">
	</head>
	<body>
		<div id="container"></div>
		<div id="info">
			<a href="https://tomhsiao1260.github.io/" target="_blank" rel="noopener">HSIAO YAO</a>
			<div id="notSupported" style="display:none">Sorry your graphics card + browser does not support hardware instancing</div>
		</div>
		<canvas id="c"></canvas>
		<script src="js/three.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script type="module">

			import { VRButton } from "./js/VRButton.js";

			main();

			function main() {
			  // 先找到渲染的 canvas 元件
			  const canvas = document.querySelector('#c');
			  // 建立 Renderer
			  const renderer = new THREE.WebGLRenderer({canvas});

			  renderer.xr.enabled = true;
			  document.body.appendChild(VRButton.createButton(renderer));

			  
			  // 建立 Camera
			  // 下面四個參數決定了一個 frustum 幾何形狀，也就是要被選染的範圍
			  const fov = 75;   // fov (field of view): 垂直視角，單位 deg
				const aspect = 2; // aspect: 畫面長寬比，默認值為 2
				const near = 0.1; // near: 最近要被渲染的距離
				const far = 5;    // far: 最遠要被渲染的距離
				const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
				// Camera 預設在原點，往 -Z 方向看
				// 調整相機位置以便看到原點的物體
				camera.position.set(0, 1.6, 0);

				// 建立 Scene
				const scene = new THREE.Scene();

				// 建立方形 Geometry
				const boxWidth = 1;
				const boxHeight = 1;
				const boxDepth = 1;
				const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

			  // 製作一個 cube 的 Mesh
				function makeInstance(geometry, color, x) {
					// 建立 Material
			    const material = new THREE.MeshPhongMaterial({color});
			    // const material = new THREE.MeshBasicMaterial({color: 0x44aa88});

			    // 利用 Geometry 和 Material 產生 Mesh
			    const cube = new THREE.Mesh(geometry, material);

			    // 將 Mesh 加進 Scene 裡
			    scene.add(cube);

			    // 更改 Mesh 位置
			    cube.position.x = x;
			    cube.position.y = 1.6;
				cube.position.z = -5;

			    return cube;
			  }

			  // 產生三個 cube 在不同位置，回傳的 mesh 成為陣列 (供後續動畫使用)
			  const cubes = [
			    makeInstance(geometry, 0x44aa88,  0),
			    makeInstance(geometry, 0x8844aa, -2),
			    makeInstance(geometry, 0xaa8844,  2),
			  ];

			  // 加入光線
				{
				  const color = 0xFFFFFF;
				  const intensity = 1;
				  const light = new THREE.DirectionalLight(color, intensity);
				  light.position.set(-1, 2, 4);
				  // 將光線加進 Scene
				  scene.add(light);
			    // {} 寫法是為了讓 const, let 參數限制在裡面 (block scope)
				}

			  // 使用 setSize 隨顯示畫面大小改變 canvas 的顯示的解析度
			  // 同時回傳 boolean 判斷 camera aspect 是否更新
			  function resizeRendererToDisplaySize(renderer) {
			    // canvas 初始的 width, height 值即為顯示的解析度，也稱為 drawingbuffer size
			    const canvas = renderer.domElement;
			    // pixelRatio 改善 HD-DPI 顯示，讓圖形更 sharp
			    const pixelRatio = window.devicePixelRatio;
			    // clientWidth 為 canvas 顯示在 browser 上的寬度 
			    const width = canvas.clientWidth * pixelRatio | 0;
			    const height = canvas.clientHeight * pixelRatio | 0;
			    // 若 clientWidth 與 width 不同會造成模糊，需重新調整
			    const needResize = canvas.width !== width || canvas.height !== height;
			    if (needResize) {
			      // 使用 setSize 改變 canvas 的 drawingbuffer size
			      renderer.setSize(width, height, false);
			    }
			    return needResize;
			  }

			  // 加入動畫 和 RWD
			  function render(time) {
			  	// convert time to seconds
			    time *= 0.001;

			    // RWD 設計
			    if (resizeRendererToDisplaySize(renderer)) {
			      // 為了避免畫面撐滿整個 browser 造成顯示上的變形
			      // 所以動態變更 camera 顯示的長寬比
			      const canvas = renderer.domElement;
			      camera.aspect = canvas.clientWidth / canvas.clientHeight;
			      camera.updateProjectionMatrix();
			    }

			    // 改變 rotation 讓每個 cube 旋轉
			    cubes.forEach((cube, ndx) => {
			      const speed = 1 + ndx * .1;
			      const rot = time * speed;
			      cube.rotation.x = rot;
			      cube.rotation.y = rot;
			    });

			    // 最終，透過 renderer 渲染出每個 frame 的結果
			    renderer.render(scene, camera);
			  }

			  // 每過一段時間就會重新 render 畫面
			  renderer.setAnimationLoop( render );

			  // 使用 WebGLRenderer 作為 Renderer
			  // 使用 PrspectiveCamera 作為 Camera (不在 scenegraph 內)
			  // scenegraph 裡的源頭為 Scene
			  // Scene 上加入了 DirectionalLight 和三個 Mesh 物件
			  // 其中三個 Mesh 共用了同個 BoxGeometry 和 PhongMaterial
			}
		</script>
	</body>
</html>
